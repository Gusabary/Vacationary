# Learning notes of Week 6

## 2.20 Thu.

### HTTPS

+ HTTPS 具备 HTTP 所不具备的一些特性：

  + 加密（防窃听）
  + 认证（防伪装）
  + 完整性保护（防篡改）

+ 加密的主要方式：

  + 对称性加密：加密解密使用同一密钥，速度快，但无法安全地传输密钥（man in the middle）
  + 非对称加密：密钥分公钥私钥，可以安全地公开公钥，但是速度慢

  而 HTTPS 采用的加密方式是先将对称性加密所需的密钥用非对称加密的方式传输给对方，之后就用这把密钥进行通信。

+ 用户如何知道某个公钥就是服务端对应的那一把，服务端的密钥经过 CA 的数字签名形成证书，用户看到证书后用 CA 的公钥解密就能得到服务端的公钥。

  注意公钥既可以用来加密也可以用来解密，主要是在不同的应用场景：

  + 数字签名：将某段数据用自己的私钥加密，只有用自己的公钥才能解开，用来证明我就是我
  + 加密通信：将某段数据用对方的公钥加密，只有用对方的私钥才能解开，用来传输只想让对方看到的数据

+ SSL 提供报文摘要功能来进行完整性保护。尽管 HTTP 也提供 MD5 报文摘要功能，但是由于没有和加密、认证一起使用，所以仍是不安全的。HTTPS 则不同。

### HTTP/2.0

+ 二进制分帧层：将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。
+ 服务端推送：在客户端请求一个资源时，会将相关的资源一并返回，客户端不需要再次发起请求。
+ 首部压缩：要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。并且使用 Huffman 编码对首部字段进行压缩。

### Socket I/O

对于一个套接字上的输入操作，通常分为两部分：

1. 等待数据从网络上到达内核缓冲区
2. 将数据从内核缓冲区拷贝至进程缓冲区

Unix 有五种 I/O 模型：

+ 阻塞式 I/O：在处理两部分时，应用进程被阻塞。
+ 非阻塞式 I/O：在处理第一部分时，应用进程需要轮询来获知第一部分是否处理完，在处理第二部分时，应用进程被阻塞。
+ I/O 复用：在处理第一部分时，应用进程被阻塞，之后被唤醒，处理第二部分时继续阻塞。和阻塞式 I/O 的区别在于它让单个进程拥有处理多个 I/O 事件的能力，应用进程在第一部分阻塞时可以同时等待多个 I/O 事件，所以又叫事件驱动 I/O，相比之下，阻塞式 I/O 在一开始就要明确等待的是哪一个 I/O 事件，当有多个事件时就需要多个线程来处理。
+ 信号驱动 I/O：在一开始用注册一个 signal handler，处理第一部分时不阻塞，处理完后内核发送一个信号通知应用进程，应用进程进入阻塞，等待处理第二部分。
+ 异步 I/O：处理两部分时，应用进程都不阻塞，等第二部分处理完内核会通知应用进程。

I/O 模型是同步还是异步取决于在处理第二部分时应用进程是否被阻塞。

![](./images/io.png)

+ select / poll / epoll 都是 I/O 多路复用的具体实现

### 多线程

+ pthread 线程：寄存器从不共享，虚拟内存总是共享。全局变量和静态变量保存在 data 段中（共享），而局部变量保存在自己的栈中（并非绝对不共享，其他线程可以通过指针访问到，因为虚存毕竟还是共享的）
+ 在 GNU C Library 中，thread group id 就是这组线程所在进程的 pid，*[reference](<https://www.gnu.org/software/libc/manual/html_node/Process-Identification.html>)*
+ 进程由五个部分组成：code，data (VM)，stack，file I/O 以及 signal table。fork 创建子进程时仅共享 code。

### C++ 类型转换

+ `dynamic_cast` 只能用于转换指向对象的指针或者对象的引用。向上转型是合法的，向下转型当前仅当有正确的多态时是合法的，侧向转型可以理解成先向下转型再向上转型（双重继承）

  考虑这样一种情景：

  ```c++
  class A {};
  class B : public A {};
  class C : public A {};
  class D : public B, public C {};
  
  // 向上转型，合法
  B *b = new B;
  A *a = dynamic_cast<A *>(b);
  
  // 向下转型，当有正确的多态时合法
  A *a = new B;  // 正确的多态
  B *b = dynamic_cast<B *>(a);
  
  // 侧向转型，合法与否的关键在于向下转型是否合法
  B *b = new D;  // 正确的多态
  C *c = dynamic_cast<C *>(b);
  // 这一步理解上可以拆成先向下转型，在向上转型:
  // D *d = dynamic_cast<D *>(b);  // 多态正确的话是可以转的
  // C *c = dynamic_cast<C *>(d);  // 无论如何都是可以转的
  ```

  也可以这么理解，转换后的对象不能比转换前的对象拥有更多信息，所以从子类转换到父类是安全的。

+ `static_cast` 可以用于转换指向对象的指针或者对象的引用，但不会像 `dynamic_cast` 那样做安全检查；也可以进行 C 风格隐式转换下合法的转换。

+ `reinterpret_cast` 用于转换不同类型的指针，只是对某个地址处的数据用不同的类型解释了一遍。

+ `const_cast` 可以将常量转成非常量，将非常量转成常量。

+ tips: `typeid` 函数可以查看变量的类型，但是输出方式是 compiler-dependent 的

+ 考虑这样一个场景：C 继承自 A 和 B，那么 C 类对象的内存布局大概会是这样：

  ```
  +-----+ <-- a1
  |  A  |
  +-----+ <-- a2
  |  B  |
  +-----+ <-- a3
  |  C  |
  +-----+
  ```

  此时 c 对象的地址为 a1，将其用 `dynamic_cast` 向上转型为 A 类对象，转型后的对象地址也为 a1；但是用 `dynamic_cast` 向上转型为 B 类对象，则转型后的对象地址为 a2。所谓转型后的对象不能比转型前拥有更多信息，可以理解成转型后的对象只是从转型前的对象中截取了一部分数据，如果转型后的对象反而拥有更多信息的话，原来紧凑的内存布局就会被破坏。

  如果用 `reinterpret_cast` 转型成 B 对象，则转型后的对象地址仍为 a1，但这样的转型没有意义。

##### Last-modified date: 2020.2.21, 3 p.m.

